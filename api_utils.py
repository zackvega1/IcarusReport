import requests
import gspread
import time
from oauth2client.service_account import ServiceAccountCredentials
from tkinter import messagebox
from helpers import calculate_elo, sort_matches_by_identifier
import math
#Coded by Zack Vega, Comments generated by AI



def fetch_event_ids(api_key, tournament_slug):
    url = 'https://api.start.gg/gql/alpha'
    headers = {
        'Authorization': f'Bearer {api_key}',
        'Content-Type': 'application/json'
    }

    query = '''
    query TournamentQuery($slug: String!) {
      tournament(slug: $slug) {
        id
        name
        events {
          id
          name
        }
      }
    }
    '''
    
    variables = {"slug": tournament_slug}
    response = requests.post(url, headers=headers, json={'query': query, 'variables': variables})
    
    if response.status_code != 200:
        messagebox.showerror("Error", "Failed to connect to the API.")
        return None
    
    data = response.json()
    
    if 'errors' in data:
        error_message = data['errors'][0].get('message', 'Unknown error')
        messagebox.showerror("Error", f"Invalid tournament slug: {tournament_slug}. Please check and try again.")
        return None

    events = data['data']['tournament']['events']
    return [(event['id'], event['name']) for event in events]

def fetch_phase_groups(api_key, event_id):
    url = 'https://api.start.gg/gql/alpha'
    headers = {
        'Authorization': f'Bearer {api_key}',
        'Content-Type': 'application/json'
    }

    query = '''
    query EventQuery($eventId: ID!) {
      event(id: $eventId) {
        id
        name
        phases {
          id
          name
        }
      }
    }
    '''

    variables = {"eventId": event_id}
    response = requests.post(url, headers=headers, json={'query': query, 'variables': variables})

    if response.status_code != 200:
        messagebox.showerror("Error", "Failed to connect to the API.")
        return None
    
    data = response.json()
    
    if 'errors' in data:
        error_message = data['errors'][0].get('message', 'Unknown error')
        messagebox.showerror("Error", f"Error fetching phases: {error_message}")
        return None

    phases = data['data']['event']['phases']
    return [(phase['id'], phase['name']) for phase in phases]

def fetch_pools(api_key, phase_id):
    url = 'https://api.start.gg/gql/alpha'
    headers = {
        'Authorization': f'Bearer {api_key}',
        'Content-Type': 'application/json'
    }

    query = '''
    query PhaseQuery($phaseId: ID!) {
      phase(id: $phaseId) {
        id
        name
        phaseGroups {
          nodes {
            id
            displayIdentifier
          }
        }
      }
    }
    '''

    variables = {"phaseId": phase_id}
    response = requests.post(url, headers=headers, json={'query': query, 'variables': variables})

    if response.status_code != 200:
        messagebox.showerror("Error", "Failed to connect to the API.")
        return None
    
    data = response.json()
    
    if 'errors' in data:
        error_message = data['errors'][0].get('message', 'Unknown error')
        messagebox.showerror("Error", f"Error fetching pools: {error_message}")
        return None

    pools = data['data']['phase']['phaseGroups']['nodes']
    return [(pool['id'], pool['displayIdentifier']) for pool in pools]

def fetch_sets_data(api_key, pool_id):
    url = 'https://api.start.gg/gql/alpha'
    headers = {
        'Authorization': f'Bearer {api_key}',
        'Content-Type': 'application/json'
    }

    query = '''
    query PoolSetsQuery($poolId: ID!, $page: Int!, $perPage: Int!) {
      phaseGroup(id: $poolId) {
        sets(page: $page, perPage: $perPage, sortType: RECENT) {
          nodes {
            identifier
            displayScore
            slots {
              entrant {
                participants {
                    id
                    gamerTag
                    user {
                        discriminator
                        id
                        images {
                            url
                            type
                        }
                    }
                }
                id
                name
              }
            }
          }
        }
      }
    }
    '''

    per_page = 50
    page = 1
    all_sets = []

    while True:
        variables = {"poolId": pool_id, "page": page, "perPage": per_page}
        response = requests.post(url, headers=headers, json={'query': query, 'variables': variables})

        if response.status_code != 200:
            messagebox.showerror("Error", "Failed to connect to the API.")
            return None
        
        data = response.json()
        
        if 'errors' in data:
            error_message = data['errors'][0].get('message', 'Unknown error')
            messagebox.showerror("Error", f"Error fetching data: {error_message}")
            return None
        
        sets_data = data['data']['phaseGroup']['sets']['nodes']
        all_sets.extend(sets_data)

        # Print all available information under participants
        for match in sets_data:
            for slot in match['slots']:
                entrant = slot.get('entrant', {})
                participants = entrant.get('participants', [])
                for participant in participants:
                    print("Participant Details:")
                    for key, value in participant.items():
                        if isinstance(value, dict):
                            print(f"  {key}:")
                            for sub_key, sub_value in value.items():
                                print(f"    {sub_key}: {sub_value}")
                        else:
                            print(f"  {key}: {value}")
                    print("----------")

        if len(sets_data) < per_page:
            break

        page += 1

    return all_sets





def connect_to_google_sheet(credentials_file, sheet_name):
    try:
        # Connect to Google Sheets
        scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
        creds = ServiceAccountCredentials.from_json_keyfile_name(credentials_file, scope)
        client = gspread.authorize(creds)
        sheet = client.open(sheet_name)
        return sheet
    except Exception as e:
        messagebox.showerror("Error", f"Failed to connect to Google Sheets: {e}")
        return None

def fetch_player_details(sheet):
    try:
        player_details_sheet = sheet.worksheet("Player Details")
        player_data = player_details_sheet.get_all_records()
        # Convert the player data into a dictionary with Player ID as the key
        player_dict = {str(player['Player ID']): player for player in player_data}
        return player_dict
    except gspread.exceptions.APIError as e:
        messagebox.showerror("Error", f"Failed to fetch player details: {e}")
        return {}


def sanitize_value(value):
    """
    Convert NaN, inf, and -inf values to 0 or a safe number.
    """
    if isinstance(value, float):
        if math.isnan(value) or math.isinf(value):
            return 0  # Replace with 0 or any other safe value
    return value

def batch_update_google_sheet(sheet, matches, tournament_name, tournament_url, tournament_type):
    try:
        player_details_sheet = sheet.worksheet("Player Details")
        match_history_sheet = sheet.worksheet("Match History")
    except gspread.exceptions.WorksheetNotFound as e:
        messagebox.showerror("Error", f"Worksheet not found: {e}")
        return
    except gspread.exceptions.APIError as e:
        messagebox.showerror("Error", f"Failed to access worksheet: {e}")
        return
    except Exception as e:
        messagebox.showerror("Error", f"Unexpected error accessing worksheet: {e}")
        return

    try:
        player_dict = fetch_player_details(sheet)
        matches = sort_matches_by_identifier(matches)
        match_history_data = []

        for match in matches:
            player1_name = match['slots'][0]['entrant']['name']
            player1_participant = match['slots'][0]['entrant']['participants'][0]
            player1_discriminator = player1_participant['user']['discriminator']

            player2_name = match['slots'][1]['entrant']['name']
            player2_participant = match['slots'][1]['entrant']['participants'][0]
            player2_discriminator = player2_participant['user']['discriminator']

            try:
                score_parts = match['displayScore'].split(' - ')
                player1_score = int(score_parts[0].split(' ')[-1])
                player2_score = int(score_parts[1].split(' ')[-1])
            except (ValueError, IndexError):
                continue

            if player1_discriminator not in player_dict:
                player_dict[player1_discriminator] = {
                    "Player Name": player1_name,
                    "Player ID": player1_discriminator,
                    "Online Elo": 1000,
                    "Offline Elo": 1000,
                    "Icarus Elo": 1000,
                    "Total Wins": 0,
                    "Total Losses": 0
                }
            if player2_discriminator not in player_dict:
                player_dict[player2_discriminator] = {
                    "Player Name": player2_name,
                    "Player ID": player2_discriminator,
                    "Online Elo": 1000,
                    "Offline Elo": 1000,
                    "Icarus Elo": 1000,
                    "Total Wins": 0,
                    "Total Losses": 0
                }

            # Fetch the current ELOs and match results
            player1_online_elo = player_dict[player1_discriminator]["Online Elo"]
            player1_offline_elo = player_dict[player1_discriminator]["Offline Elo"]
            player1_icarus_elo = player_dict[player1_discriminator]["Icarus Elo"]

            player2_online_elo = player_dict[player2_discriminator]["Online Elo"]
            player2_offline_elo = player_dict[player2_discriminator]["Offline Elo"]
            player2_icarus_elo = player_dict[player2_discriminator]["Icarus Elo"]

            # Determine which Elo values to use based on tournament type
            if tournament_type.lower() == "online":
                player1_elo = player1_online_elo
                player2_elo = player2_online_elo
            else:
                player1_elo = player1_offline_elo
                player2_elo = player2_offline_elo

            # Calculate new ELOs
            new_elo1, new_elo2, change1, change2 = calculate_elo(player1_elo, player2_elo, player1_score, player2_score)
            new_icarus_elo1, new_icarus_elo2, _, _ = calculate_elo(player1_icarus_elo, player2_icarus_elo, player1_score, player2_score)

            # Sanitize values to prevent JSON serialization issues
            new_elo1 = sanitize_value(new_elo1)
            new_elo2 = sanitize_value(new_elo2)
            new_icarus_elo1 = sanitize_value(new_icarus_elo1)
            new_icarus_elo2 = sanitize_value(new_icarus_elo2)
            change1 = sanitize_value(change1)
            change2 = sanitize_value(change2)

            # Update Player Details based on tournament type
            if tournament_type.lower() == "online":
                player_dict[player1_discriminator]["Online Elo"] = int(new_elo1)
                player_dict[player2_discriminator]["Online Elo"] = int(new_elo2)
            else:
                player_dict[player1_discriminator]["Offline Elo"] = int(new_elo1)
                player_dict[player2_discriminator]["Offline Elo"] = int(new_elo2)

            # Update Icarus Elo
            player_dict[player1_discriminator]["Icarus Elo"] = int(new_icarus_elo1)
            player_dict[player2_discriminator]["Icarus Elo"] = int(new_icarus_elo2)

            # Update wins and losses
            if player1_score > player2_score:
                player_dict[player1_discriminator]["Total Wins"] += 1
                player_dict[player2_discriminator]["Total Losses"] += 1
            elif player1_score < player2_score:
                player_dict[player1_discriminator]["Total Losses"] += 1
                player_dict[player2_discriminator]["Total Wins"] += 1

            # Add match details to the batch data
            match_history_data.append([
                player1_name, player1_score, player2_name, player2_score, player1_elo,
                player2_elo, change1, change2, tournament_name, tournament_url
            ])

        # Batch append match history data
        batch_size = 256
        for i in range(0, len(match_history_data), batch_size):
            batch = match_history_data[i:i + batch_size]
            batch = [[sanitize_value(cell) for cell in row] for row in batch]
            try:
                match_history_sheet.append_rows(batch)
            except gspread.exceptions.APIError as e:
                messagebox.showerror("Error", f"Failed to append batch to Match History: {e}")
                return
            time.sleep(2)

        # Update Player Details Sheet
        updated_player_details = list(player_dict.values())
        player_details_sheet.clear()
        player_details_sheet.append_row(['Player Name', 'Player ID', 'Online Elo', 'Offline Elo', 'Icarus Elo', 'Total Wins', 'Total Losses'])

        for i in range(0, len(updated_player_details), batch_size):
            batch = [[
                player["Player Name"],
                player["Player ID"],
                int(player["Online Elo"]),
                int(player["Offline Elo"]),
                int(player["Icarus Elo"]),
                int(player["Total Wins"]),
                int(player["Total Losses"])
            ] for player in updated_player_details[i:i + batch_size]]

            batch = [[sanitize_value(cell) for cell in row] for row in batch]
            try:
                player_details_sheet.append_rows(batch)
            except gspread.exceptions.APIError as e:
                messagebox.showerror("Error", f"Failed to append batch to Player Details: {e}")
                return
            time.sleep(2)

    except Exception as e:
        messagebox.showerror("Error", f"Failed to update Google Sheets: {e}")